##redis lock <br>
> 1. 命令原子性 <br>
> 2. 别人不能释放 <br>
> 3. 释放锁的操作必须原子性(例如：Lua脚本) <br>
````
       客户端1获取锁成功。
       客户端1访问共享资源。
       客户端1为了释放锁，先执行'GET'操作获取随机字符串的值。
       客户端1判断随机字符串的值，与预期的值相等。
       客户端1由于某个原因阻塞住了很长时间。
       过期时间到了，锁自动释放了。
       客户端2获取到了对应同一个资源的锁。
       客户端1从阻塞中恢复过来，执行DEL操纵，释放掉了客户端2持有的锁。
````  
> 4. 只要设置了过期时间就会有问题(token解决)
> 5. RedLock依赖系统时钟
> 6. 加锁的用途，为什么需要加锁
````
    为了效率(efficiency)。使用简单的Redis锁就够了
        协调各个客户端避免做重复的工作。即使锁偶尔失效了，只是
        可能把某些操作多做一遍而已，不会产生其它的不良后果。比
        如重复发送了一封同样的email，幂等的定时任务。
    为了正确性(correctness)。应该考虑类似Zookeeper的方案，或者支持事务的数据库。
        在任何情况下都不允许锁失效的情况发生，因为一旦发生，就
        可能意味着数据不一致(inconsistency)，数据丢失，文件损
        坏，或者其它严重的问题。比如，扣减库存。
````
